<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>。。。。</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学海无涯，止于至善">
<meta property="og:type" content="website">
<meta property="og:title" content="。。。。">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="。。。。">
<meta property="og:description" content="学海无涯，止于至善">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="。。。。">
<meta name="twitter:description" content="学海无涯，止于至善">
  
    <link rel="alternate" href="/atom.xml" title="。。。。" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">。。。。</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">勤学如春起之苗，不见其增，日有所长。缀学如磨刀之石，不见其损，日有所亏。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文章</a>
        
          <a class="main-nav-link" href="/log">日志</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-redis安装笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/redis安装笔记/" class="article-date">
  <time datetime="2018-07-12T03:28:36.603Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/redis安装笔记/">Redis 安装的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><pre><code>Linux下载地址：wget http://download.redis.io/releases/redis-2.8.3.tar.gz
windows :https://github.com/dmajkic/redis/downloads
解压：tar xzf redis-2.8.3.tar.zg
cd redis-2.8.3
</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code>linux启动：./redis-server
windows启动：d: &amp; cd D:\Redis\redis-2.4.5
redis-server.exe redis.conf
客户端测试是否启动：./redis-cli
&gt;set foo bar
Ok 
&gt;set foo
&quot;bar&quot;
</code></pre><h2 id="可视化工具下载"><a href="#可视化工具下载" class="headerlink" title="可视化工具下载"></a>可视化工具下载</h2><pre><code>http://redisdesktop.com/download
</code></pre><h2 id="检查端口"><a href="#检查端口" class="headerlink" title="检查端口"></a>检查端口</h2><pre><code>[root@luo redis-2.8.3]# firewall-cmd --query-port=6379/tcp
no 
[root@luo redis-2.8.3]# firewall-cmd --add-port=6379/tcp
success
[密码所在redis.conf]: http://images2015.cnblogs.com/blog/758998/201612/758998-20161214214725636-1530839128.png
设置密码：config set requirepass 1234 ![密码所在redis.conf]
    auth 1234
</code></pre><p>·· bash<br>1.基本配置<br>内存单位的表示</p>
<h1 id="1k-gt-1000-bytes"><a href="#1k-gt-1000-bytes" class="headerlink" title="1k =&gt; 1000 bytes"></a>1k =&gt; 1000 bytes</h1><h1 id="1kb-gt-1024-bytes"><a href="#1kb-gt-1024-bytes" class="headerlink" title="1kb =&gt; 1024 bytes"></a>1kb =&gt; 1024 bytes</h1><h1 id="1m-gt-1000000-bytes"><a href="#1m-gt-1000000-bytes" class="headerlink" title="1m =&gt; 1000000 bytes"></a>1m =&gt; 1000000 bytes</h1><h1 id="1mb-gt-1024-1024-bytes"><a href="#1mb-gt-1024-1024-bytes" class="headerlink" title="1mb =&gt; 1024*1024 bytes"></a>1mb =&gt; 1024*1024 bytes</h1><h1 id="1g-gt-1000000000-bytes"><a href="#1g-gt-1000000000-bytes" class="headerlink" title="1g =&gt; 1000000000 bytes"></a>1g =&gt; 1000000000 bytes</h1><h1 id="1gb-gt-102410241024-bytes"><a href="#1gb-gt-102410241024-bytes" class="headerlink" title="1gb =&gt; 102410241024 bytes"></a>1gb =&gt; 1024<em>1024</em>1024 bytes</h1><p>单位中不区分大小写1GB 1Gb 1gB是一样的</p>
<p>后台运行，yes是后台运行，no前台运行，将输出，输出到终端（默认）</p>
<p>daemonize yes</p>
<p>如果daemonize参数为yes的话就会产生pid文件，一下是pid文件的定义</p>
<p>pidfile /usr/local/redis-master/run/redis.pid</p>
<p>监听的端口</p>
<p>port 6379</p>
<p>绑定监听的IP地址</p>
<p>bind 127.0.0.1</p>
<p>如果在本地调用redis可以直接用sock文件</p>
<p>unixsocket /tmp/redis.sock  //sock文件的位置</p>
<p>unixsocketperm 755            //sock文件的权限</p>
<p>如果一个链接在N秒内是空闲的，就将其关闭</p>
<p>timeout 0</p>
<p>如果对方down了或者中间网络断了发送ACK到客户端在指定的时间内没有收到对方的回应就断开TCP链接（时间单位秒记），此参数会受到内核参数的影响，推荐配置60。</p>
<p>tcp-keepalive 0</p>
<p>指定输出消息的级别</p>
<h1 id="debug-调试级别，详细信息，信息量大"><a href="#debug-调试级别，详细信息，信息量大" class="headerlink" title="debug (调试级别，详细信息，信息量大)"></a>debug (调试级别，详细信息，信息量大)</h1><h1 id="verbose-详细信息，信息量较大"><a href="#verbose-详细信息，信息量较大" class="headerlink" title="verbose (详细信息，信息量较大)"></a>verbose (详细信息，信息量较大)</h1><h1 id="notice-通知，生产环境推荐"><a href="#notice-通知，生产环境推荐" class="headerlink" title="notice (通知，生产环境推荐)"></a>notice (通知，生产环境推荐)</h1><h1 id="warning-错误信息警告信息"><a href="#warning-错误信息警告信息" class="headerlink" title="warning (错误信息警告信息)"></a>warning (错误信息警告信息)</h1><p>loglevel notice</p>
<p>日志输出文件，默认在前端运行的时候此key的默认值是stdout输出到终端，如果用守护进程运行此key的stdout的时候将日志输入到/dev/null，如果想记录日志，就必须为其指定logfile位置</p>
<p>logfile /var/log/redis.log</p>
<p>将日志记录的哦syslog</p>
<p>syslog-enabled no</p>
<p>指定syslog的身份</p>
<p>syslog-ident redis</p>
<p>指定syslog的级别，必须是LOCAL0-LOCAL7之间</p>
<p>syslog-facility local0</p>
<p>设置数据库的数量</p>
<p>databases 16</p>
<p>设置数据库的数量。默认数据库DB 0，你可以选择一个不同的per-connection的使用SELECT&lt;dbid&gt;这儿的DBID是一个介于0和’databases’-1</p>
<p>databases 16</p>
<p>2.快照配置</p>
<p>将DB保存到磁盘的规则定义（快照）</p>
<p>格式：save &lt;seconds&gt; &lt;changes&gt;</p>
<p>例子：save 900 1  //在900秒（15分钟）内如果至少有1个键值发生变化  就保存</p>
<pre><code>save 300 10  //在300秒（6分钟）内如果至少有10个键值发生变化  就保存  
</code></pre><p>save 900 1                      //每一条表示一个存盘点<br>save 300 10<br>save 60 10000</p>
<p>如果启用如上的快照（RDB），在一个存盘点之后，可能磁盘会坏掉或者权限问题，redis将依然能正常工作</p>
<p>stop-writes-on-bgsave-error yes</p>
<p>是否将字符串用LZF压缩到.rdb 数据库中，如果想节省CPU资源可以将其设置成no，但是字符串存储在磁盘上占用空间会很大，默认是yes</p>
<p>rdbcompression yes</p>
<p>rdb文件的校验，如果校验将避免文件格式坏掉，如果不校验将在每次操作文件时要付出校验过程的资源新能，将此参数设置为no，将跳过校验</p>
<p>rdbchecksum yes</p>
<p>转储数据的文件名</p>
<p>dbfilename dump.rdb</p>
<p>redis的工作目录，它会将转储文件存储到这个目录下，并生成一个附加文件</p>
<p>dir /usr/local/redis-master/db</p>
<p>3.主从参数<br>如果本地是salve服务器那么配置该项</p>
<h1 id="slaveof-lt-masterip-gt-lt-masterport-gt"><a href="#slaveof-lt-masterip-gt-lt-masterport-gt" class="headerlink" title="slaveof &lt;masterip&gt; &lt;masterport&gt;"></a>slaveof &lt;masterip&gt; &lt;masterport&gt;</h1><p>slaveof 127.0.0.1 65532</p>
<p>master的验证密码</p>
<p>masterauth &lt;master-password&gt;</p>
<p>当从主机脱离主的链接时，如果此值为yes当客户端查询从时，回响应客户端，如果是第一次同步回返回一个日期数据或这空值，如果设置为no，则返回“SYNC with master in progress”到INFO and SLAVEOF</p>
<p>slave-serve-stale-data yes</p>
<p>从服务器只读（默认）</p>
<p>slave-read-only yes</p>
<p>从发送ping到主的时间间隔(单位：秒)</p>
<p>repl-ping-slave-period 10</p>
<p>批量传输I / O超时和主数据或ping响应超时 默认60s 必须大于repl-ping-slave-period值</p>
<p>repl-timeout 60</p>
<p>此选项如果是“yes”那么Redis的使用数量较少的TCP数据包和更少的带宽将数据发送到，在从主机上延迟40毫秒（linux kernel中的40毫秒）出现。如果是no将在slave中减少延迟，但是流量使用回相对多一些，如果用多个从主机，此处建议设置成yes</p>
<p>repl-disable-tcp-nodelay no</p>
<p>从主机的优先级，如果当主主机挂了的时候，将从从主机中选取一个作为其他从机的主，首先优先级的数字最低的将成为主，0是一个特殊的级别，0将永远不会成为主。默认值是100.</p>
<p>slave-priority 100<br>·· bash</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/12/redis安装笔记/" data-id="cjji0j0oi0008n00l8spy8lpr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java线程池创建配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/09/Java线程池创建配置/" class="article-date">
  <time datetime="2018-07-09T01:02:38.271Z" itemprop="datePublished">2018-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/09/Java线程池创建配置/">Executors 提供的5中不同的线程池创建配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool():"></a>newCachedThreadPool():</h1><h2 id="它是一种用于处理大量短时间工作任务的线程池，具有特点：它试图缓存线程并重用，当无线程线程可用，将会创建新的"><a href="#它是一种用于处理大量短时间工作任务的线程池，具有特点：它试图缓存线程并重用，当无线程线程可用，将会创建新的" class="headerlink" title="它是一种用于处理大量短时间工作任务的线程池，具有特点：它试图缓存线程并重用，当无线程线程可用，将会创建新的"></a>它是一种用于处理大量短时间工作任务的线程池，具有特点：它试图缓存线程并重用，当无线程线程可用，将会创建新的</h2><pre><code>工作线程，若线程闲置超过60秒，则将会终止，并移出线程池，长期闲置这种线程不会消耗什么资源，其内部使用
SynchronousQueue作为工作队列；
</code></pre><h1 id="newFixedThreadPool-int-nThread-："><a href="#newFixedThreadPool-int-nThread-：" class="headerlink" title="newFixedThreadPool(int nThread)："></a>newFixedThreadPool(int nThread)：</h1><h2 id="重用指定数目nThread的线程，其背后实现的是无界的工作队列，任何时候最多有nThread个工作线程是活动的，这意味着"><a href="#重用指定数目nThread的线程，其背后实现的是无界的工作队列，任何时候最多有nThread个工作线程是活动的，这意味着" class="headerlink" title="重用指定数目nThread的线程，其背后实现的是无界的工作队列，任何时候最多有nThread个工作线程是活动的，这意味着"></a>重用指定数目nThread的线程，其背后实现的是无界的工作队列，任何时候最多有nThread个工作线程是活动的，这意味着</h2><pre><code>如果任务数量超过线程数目，，将在工作队列中等待空闲线程出现，如果有工作线程退出，将会有线的工作线程创建，以
保证nThread；
</code></pre><h1 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor():"></a>newSingleThreadExecutor():</h1><h2 id="它的特点是工作线程被限制为1，操作一个无界的工作队列，因此它保证所有任务都被顺序执行，最多会有一个工作任务处于"><a href="#它的特点是工作线程被限制为1，操作一个无界的工作队列，因此它保证所有任务都被顺序执行，最多会有一个工作任务处于" class="headerlink" title="它的特点是工作线程被限制为1，操作一个无界的工作队列，因此它保证所有任务都被顺序执行，最多会有一个工作任务处于"></a>它的特点是工作线程被限制为1，操作一个无界的工作队列，因此它保证所有任务都被顺序执行，最多会有一个工作任务处于</h2><pre><code>活动状态，并且不允许使用者改变工作实例，因此可避免改变线程数目；
</code></pre><h1 id="newSingleThreadScheduledExecutor-和newScheduledThreadPool-int-corePoolSize"><a href="#newSingleThreadScheduledExecutor-和newScheduledThreadPool-int-corePoolSize" class="headerlink" title="newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize):"></a>newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize):</h1><h2 id="创建的是个ScheduleExecutorService，可以进行定时或周期性的工作调度，区别在于是单一工作线程还是多个工作线程；"><a href="#创建的是个ScheduleExecutorService，可以进行定时或周期性的工作调度，区别在于是单一工作线程还是多个工作线程；" class="headerlink" title="创建的是个ScheduleExecutorService，可以进行定时或周期性的工作调度，区别在于是单一工作线程还是多个工作线程；"></a>创建的是个ScheduleExecutorService，可以进行定时或周期性的工作调度，区别在于是单一工作线程还是多个工作线程；</h2><h1 id="newWorkStealingPool-parallelism"><a href="#newWorkStealingPool-parallelism" class="headerlink" title="newWorkStealingPool(parallelism):"></a>newWorkStealingPool(parallelism):</h1><h2 id="java-8才加入这个创建方式，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行的处理任务，不保证处理顺序。"><a href="#java-8才加入这个创建方式，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行的处理任务，不保证处理顺序。" class="headerlink" title="java 8才加入这个创建方式，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行的处理任务，不保证处理顺序。"></a>java 8才加入这个创建方式，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行的处理任务，不保证处理顺序。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/09/Java线程池创建配置/" data-id="cjji0j0oi0003n00lkq9xt5ct" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ActiveMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/06/ActiveMQ/" class="article-date">
  <time datetime="2018-07-06T06:51:56.457Z" itemprop="datePublished">2018-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/06/ActiveMQ/">ActiveMQ总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="下载ActiveMQ-下载"><a href="#下载ActiveMQ-下载" class="headerlink" title="下载ActiveMQ 下载"></a>下载ActiveMQ <a href="http://activemq.apache.org/" target="_blank" rel="noopener">下载</a></h2><h2 id="生产者："><a href="#生产者：" class="headerlink" title="生产者："></a>生产者：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ConnectionFactory connectionFactory=new ActiveMQConnectionFactory( //创建链接工厂</span><br><span class="line">          ActiveMQConnectionFactory.DEFAULT_USER,</span><br><span class="line">          ActiveMQConnectionFactory.DEFAULT_PASSWORD,</span><br><span class="line">          ActiveMQConnectionFactory.DEFAULT_BROKER_BIND_URL</span><br><span class="line">        );</span><br><span class="line">        Connection connection=null;</span><br><span class="line">        Session session=null;</span><br><span class="line">        Destination destination=null;</span><br><span class="line">        MessageProducer messageProducer=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection=connectionFactory.createConnection(); //从工厂获取连接</span><br><span class="line">            //connection.setClientID(<span class="string">"2"</span>);//订阅消息发布者时</span><br><span class="line">            connection.start();//打开连接</span><br><span class="line">            session=connection.createSession(Boolean.FALSE,Session.AUTO_ACKNOWLEDGE);//创建session</span><br><span class="line">            // destination=session.createTopic(<span class="string">"topic1"</span>);//创建订阅主题</span><br><span class="line">            destination=session.createQueue(<span class="string">"queuel"</span>);//创建队列</span><br><span class="line">            messageProducer=session.createProducer(destination);//创建生产者</span><br><span class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);//设置消息持久化</span><br><span class="line">            TextMessage textMessage=session.createTextMessage();//创建消息对象</span><br><span class="line">            textMessage.setText(<span class="string">"hello word"</span>);//添加消息内容</span><br><span class="line">            messageProducer.send(textMessage); //发送消息</span><br><span class="line">            //session.commit();//session提交</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();//关闭连接</span><br><span class="line">            &#125; catch (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	public class Comm implements MessageListener &#123;//实现消息监听借口</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Comm().mqdemm();</span><br><span class="line">    &#125;</span><br><span class="line">    public void  <span class="function"><span class="title">mqdemm</span></span>()&#123;</span><br><span class="line">        Connection connection=null;</span><br><span class="line">        Session session=null;</span><br><span class="line">        Destination destination=null;</span><br><span class="line">        DeliveryMode deliveryMode=null;</span><br><span class="line">        MessageConsumer messageConsumer=null;</span><br><span class="line">        ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(//创建连接工厂</span><br><span class="line">                ActiveMQConnectionFactory.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnectionFactory.DEFAULT_PASSWORD,</span><br><span class="line">                ActiveMQConnectionFactory.DEFAULT_BROKER_BIND_URL</span><br><span class="line">        );</span><br><span class="line">        try &#123;</span><br><span class="line">            connection=connectionFactory.createConnection();//从工厂获取连接</span><br><span class="line">            //connection.setClientID(<span class="string">"2"</span>);//订阅消息发布者时</span><br><span class="line">            connection.start();//打开连接</span><br><span class="line">            session=connection.createSession(Boolean.FALSE,Session.AUTO_ACKNOWLEDGE);//创建session</span><br><span class="line">            topic=session.createTopic(<span class="string">"topic1"</span>);//创建订阅主题</span><br><span class="line">            destination=session.createQueue(<span class="string">"queuel"</span>);//创建队列</span><br><span class="line">            messageConsumer=session.createConsumer(destination);//创建消费者</span><br><span class="line">            //messageConsumer=session.createDurableSubscriber(topic,<span class="string">"aaaa"</span>);//订阅者</span><br><span class="line">            messageConsumer.setMessageListener(this);//设置监听对象</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();//关闭连接</span><br><span class="line">            &#125; catch (JMSException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message) &#123;//实现接口</span><br><span class="line">        TextMessage nsg = (TextMessage) message;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(nsg.getText());//打印消息内容</span><br><span class="line">        &#125; catch (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/06/ActiveMQ/" data-id="cjji0j0n70000n00loisxw30b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java并发处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/04/java并发处理/" class="article-date">
  <time datetime="2018-07-04T09:32:11.913Z" itemprop="datePublished">2018-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/04/java并发处理/">处理并发和同步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如何处理并发和同步："><a href="#如何处理并发和同步：" class="headerlink" title="如何处理并发和同步："></a>如何处理并发和同步：</h2><h3 id="1-在程序中使用线程的锁机制完成并发控制，"><a href="#1-在程序中使用线程的锁机制完成并发控制，" class="headerlink" title="1. 在程序中使用线程的锁机制完成并发控制，"></a>1. 在程序中使用线程的锁机制完成并发控制，</h3><h3 id="2-在利用数据库的锁机制，如：悲观锁和乐观锁"><a href="#2-在利用数据库的锁机制，如：悲观锁和乐观锁" class="headerlink" title="2. 在利用数据库的锁机制，如：悲观锁和乐观锁"></a>2. 在利用数据库的锁机制，如：悲观锁和乐观锁</h3><h4 id="悲观锁-："><a href="#悲观锁-：" class="headerlink" title="悲观锁 ："></a>悲观锁 ：</h4><pre><code>就是在查询语句后面加上for update，查询时锁住表的字段不可更新操作，直到事务提交，才会释放锁，
缺点：对于大量数据操作时，资源浪费严重
</code></pre><h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><pre><code>在表结构基础上添加一个版本冗余字段，没对数据库中数据操作一次该字段进行一次加1，只有比当前版本大的数据才可入库，
对于大量数据的操作一般都是用乐观锁。
</code></pre><h2 id="对于大量数据处理："><a href="#对于大量数据处理：" class="headerlink" title="对于大量数据处理："></a>对于大量数据处理：</h2><h3 id="分表存储，如通过时间分，或者某些字段分"><a href="#分表存储，如通过时间分，或者某些字段分" class="headerlink" title="分表存储，如通过时间分，或者某些字段分"></a>分表存储，如通过时间分，或者某些字段分</h3><h3 id="对于大量并发请："><a href="#对于大量并发请：" class="headerlink" title="对于大量并发请："></a>对于大量并发请：</h3><h3 id="1-提高访问带宽，"><a href="#1-提高访问带宽，" class="headerlink" title="1.提高访问带宽，"></a>1.提高访问带宽，</h3><h3 id="2-搭建负载均衡服务器，"><a href="#2-搭建负载均衡服务器，" class="headerlink" title="2.搭建负载均衡服务器，"></a>2.搭建负载均衡服务器，</h3><h3 id="3-oracle分表机制，进行分表，"><a href="#3-oracle分表机制，进行分表，" class="headerlink" title="3.oracle分表机制，进行分表，"></a>3.oracle分表机制，进行分表，</h3><h3 id="4-不持续操作数据库，使用缓存技术，"><a href="#4-不持续操作数据库，使用缓存技术，" class="headerlink" title="4.不持续操作数据库，使用缓存技术，"></a>4.不持续操作数据库，使用缓存技术，</h3><h3 id="5，使用静态页面"><a href="#5，使用静态页面" class="headerlink" title="5，使用静态页面"></a>5，使用静态页面</h3><p>More info: <a href="https://www.cnblogs.com/lr393993507/p/5909804.html" target="_blank" rel="noopener">更多</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/04/java并发处理/" data-id="cjji0j0oi0006n00lkfgqvq4k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java内存机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/04/java内存机制/" class="article-date">
  <time datetime="2018-07-04T09:32:11.913Z" itemprop="datePublished">2018-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/04/java内存机制/">java内存机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h2><pre><code>内存空间较小，用于记录字节码执行的行号，多线程切换线程记录执行行数，属于线程私有，并且不会OutOfMemoryError 
</code></pre><h2 id="java虚拟机栈："><a href="#java虚拟机栈：" class="headerlink" title="java虚拟机栈："></a>java虚拟机栈：</h2><pre><code>java方法执行的内存模型，每个方法执行都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口。
方法的执行过程就是进栈和出栈的过程。所说的堆内存和栈内存中栈就是虚拟机栈，也可以说是虚拟机栈中
的局部变量表。局部变量表存放编译器可知的各种基本数据类型和对象引用。属于线程私有，如果线程请求的
栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展
当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。
</code></pre><h2 id="本地方法栈与虚拟机栈相似。"><a href="#本地方法栈与虚拟机栈相似。" class="headerlink" title="本地方法栈与虚拟机栈相似。"></a>本地方法栈与虚拟机栈相似。</h2><h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><pre><code>内存中最大的一块，堆是线程共享的，虚拟机启动时创建，用于存放对象实例和数组，几乎所有的对象实例都从
堆中分配内存。gc回收就是回收这块内存。
从内存回收的角度看：收集器大多采用分代收集算法，即新生代和老年代或者eden空间、from durvivor 空间、
to survivor空间等；
从内存分配角度看: 线程共享的java堆中可能划分出多个线程私有的分配缓冲区。不同的分配是为了更好的管理和分配内存，
无论怎么分存的都是内存对象，
不需要物理连续地址，需逻辑连续。
</code></pre><h2 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h2><pre><code>也是各线程共享的内存区域，用于存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，
gc在该区域回收的是常量池和对数据类型的卸载，会抛出OutOfMemoryError
</code></pre><h2 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h2><pre><code>方法区的一部分，class文件除了有类的版本，字段，方法，接口还有常量池，用于放编译期生成的各种字面量和符号引用，
这部分内容将在类加载后存放到方法区的运行时常量池，
</code></pre><p>More info: <a href="https://www.cnblogs.com/dingyingsi/p/3760447.html" target="_blank" rel="noopener">更多</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/04/java内存机制/" data-id="cjji0j0oi0007n00laup7vgqd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvmGC机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/22/jvmGC机制/" class="article-date">
  <time datetime="2018-06-22T02:18:08.226Z" itemprop="datePublished">2018-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/22/jvmGC机制/">gc垃圾回收机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="新域"><a href="#新域" class="headerlink" title="新域"></a>新域</h2><pre><code>几乎所有对象都在新域里，新域里的对象大多都是短命的，通过GC复制算法将使用空间的存活对象
复制到保留空间中，然后清空使用空间中不存活的对象，两个空间对换名称，重复复制几次，将最终存活的少量对象
发到survior里面，survivor再放到老域
</code></pre><h2 id="老域"><a href="#老域" class="headerlink" title="老域"></a>老域</h2><pre><code>存在对象使用追踪算法，称为标记-清除-压缩（开销大）收集器；满了触发full GC（很耗内存）进行回收
</code></pre><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><pre><code>+ 如果GC一次运行周期超过3-5秒，这会很影响应用程序的运行，如果可以，应该减少JVM堆的大小了。
+ 通常情况下，JVM堆的大小应为物理内存的80%。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/22/jvmGC机制/" data-id="cjji0j0ox0009n00lblh3tq92" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BIO,NIO,AIO不同" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/21/BIO,NIO,AIO不同/" class="article-date">
  <time datetime="2018-06-21T08:00:23.930Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/BIO,NIO,AIO不同/">BIO,NIO,AIO不同</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><pre><code>在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，
然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，
而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，
客户端会线程会等待请求结束后才继续执行。
</code></pre><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><pre><code> NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，
 如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。
 也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会
 带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），
 而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重
 负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。

NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再
将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，
而是有效的请求，对应一个线程，当连接
没有数据时，是没有工作线程来处理的。
</code></pre><p>   BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则<br>   是使用单线程或者只使用少量的多线程，每个连接共用一个线程。<br>    NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以<br>    所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，<br>    才开启一个线程进行处理，也就是一个请求一个线程模式。</p>
<pre><code>在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。
</code></pre><p>　　HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，<br>    这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，<br>    当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保<br>    持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理<br>    只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，<br>    产生响应，这个就实现了异步处理。</p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><pre><code>在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：
</code></pre><h3 id="AsynchronousSocketChannel"><a href="#AsynchronousSocketChannel" class="headerlink" title="AsynchronousSocketChannel"></a>AsynchronousSocketChannel</h3><h3 id="AsynchronousServerSocketChannel"><a href="#AsynchronousServerSocketChannel" class="headerlink" title="AsynchronousServerSocketChannel"></a>AsynchronousServerSocketChannel</h3><h3 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h3><h3 id="AsynchronousDatagramChannel"><a href="#AsynchronousDatagramChannel" class="headerlink" title="AsynchronousDatagramChannel"></a>AsynchronousDatagramChannel</h3><pre><code>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读
操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，
当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法
都是异步的，完成后会主动调用回调函数。  

其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。

BIO是一个连接一个线程。

NIO是一个请求一个线程。

AIO是一个有效请求一个线程。


Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，
即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，
当然可以通过线程池机制改善。

Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，
多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完
成了再通知服务器应用去启动线程进行处理，

BIO、NIO、AIO适用场景分析:

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，
并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

NIO方式适用于连接数目多且连接比较短（轻操作）的架构，
比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，
充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/21/BIO,NIO,AIO不同/" data-id="cjji0j0oi0001n00lu258xw2n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL时间增加" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/21/MySQL时间增加/" class="article-date">
  <time datetime="2018-06-21T07:35:58.629Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/MySQL时间增加/">MySQL 为日期增加一个时间间隔</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> @dt = now();  </span><br><span class="line">select date_add(@dt, interval 1 day);   - 加1天  </span><br><span class="line">select date_add(@dt, interval 1 hour);   -加1小时  </span><br><span class="line">select date_add(@dt, interval 1 minute);    - 加1分钟  </span><br><span class="line">select date_add(@dt, interval 1 second); -加1秒  </span><br><span class="line">select date_add(@dt, interval 1 microsecond);-加1毫秒  </span><br><span class="line">select date_add(@dt, interval 1 week);-加1周  </span><br><span class="line">select date_add(@dt, interval 1 month);-加1月  </span><br><span class="line">select date_add(@dt, interval 1 quarter);-加1季  </span><br><span class="line">select date_add(@dt, interval 1 year);-加1年</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://blog.csdn.net/mr_linjw/article/details/49849691" target="_blank" rel="noopener">更多</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/21/MySQL时间增加/" data-id="cjji0j0oi0004n00lnr2wzuzk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/20/hello-world/" class="article-date">
  <time datetime="2018-06-20T03:57:25.286Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/20/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/20/hello-world/" data-id="cjji0j0oi0005n00l8vbcqb5y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/12/redis安装笔记/">Redis 安装的坑</a>
          </li>
        
          <li>
            <a href="/2018/07/09/Java线程池创建配置/">Executors 提供的5中不同的线程池创建配置</a>
          </li>
        
          <li>
            <a href="/2018/07/06/ActiveMQ/">ActiveMQ总结</a>
          </li>
        
          <li>
            <a href="/2018/07/04/java并发处理/">处理并发和同步</a>
          </li>
        
          <li>
            <a href="/2018/07/04/java内存机制/">java内存机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 张博<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章</a>
  
    <a href="/log" class="mobile-nav-link">日志</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>